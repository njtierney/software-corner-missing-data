---
title: "Some ideas for exploring missing data"
format: docx
fig-format: retina
bibliography: references.bib
---

Nicholas Tierney

Infectious Disease Ecology and Modelling group

Telethon Kids Institute, Perth, WA, Australia

```{r}
#| include: false
rodents <- read_csv("data/rodents.csv")
```

```{r}
#| label: load-pkgs
options(tidyverse.quiet = TRUE)
library(tidyverse)
library(visdat)
library(naniar)
library(knitr)
```


# Introduction

If you've done data analysis, then chances are you've encountered missing data. I've encountered my fair share of missing data and I felt so frustrated by how hard it was to handle and wrangle with them that I have written two R packages (visdat, naniar), and several papers on the topic.

The goal of this article is to share some condensed ideas on exploring missing data, using the software I've written, `naniar`, and `visdat`. To that end, we will focus on four questions, how do we:

1.  Start looking at missing data?
2.  Explore missingness in variables?
3.  Explore missingness relationships?
4.  Explore imputed values

# The data

The data used for this paper is measurements of rodents in Kansas, from @hope2023. This data was initially found in Allison Horst's "Exploring missing values in naniar" shiny application: https://allisonhorst.shinyapps.io/missingexplorer/. In this paper we use a different subset of the data. For information on the metadata of the paper see http://lter.konza.ksu.edu/content/csm08-small-mammal-host-parasite-sampling-data-16-linear-trapping-transects-located-8-lter. We are looking at four species of rodents, the Eastern woodrat, Prairie vole, Western harvest mouse, and Deer mouse. Below is a snapshot of the first 10 rows of the data:

```{r}
rodents %>% 
  slice_head(n = 10) %>% 
  kable()
```

# Start looking at missing data?

We can use the `visdat` package [@visdat] to get an overview of the missingness of an entire data set. It was heavily inspired by [`csv-fingerprint`](https://setosa.io/blog/2014/08/03/csv-fingerprints/), and functions like `missmap`, from `Amelia` [@amelia].

We can use `visdat`'s `vis_miss()` function to visualise the missingness of a whole dataframe. @fig-vis-miss gives an example where it displays the data as missing, or not missing, and provides the amount of missings in each columns.


```{r}
#| label: fig-vis-miss
#| fig-height: 3
#| fig-cap: "An overview of missing data in the rodents dataset. The x axis shows the variables of the data, along with the amount of missingness in that variable, and the y axis shows the rows. Each cell represents the missingness of a datum. The overall missingness is given in a percentage below in the legend. We learn that there is nearly 29% missing data overall, the missing data occurs in total_length, tail_length, hind_foot_length, ear_length, weight, and age."
vis_miss(rodents)
```

We learn that there is nearly 29% missing data overall, the missing data occurs in total_length, tail_length, hind_foot_length, ear_length, weight, and age, and mostly in total length and ear_length. 

### Facetting in visdat

You can also split up the `vis_miss` plots into several facetted plots via the `facet` argument. For example, in @fig-vis-miss-facet we facet by the `common_name` variable.

```{r}
#| label: fig-vis-miss-facet
#| fig-height: 3
#| fig-cap: "An further overview of missing data in the rodents dataset. Similar to the previous graphic, we now present a facetted series of sub plots, one for each species. We learn from this that the missingness seems to be the same across each species"
vis_miss(rodents, facet = species) 
```

We learn from this that the missingness appears to occur in each species at approximately the same rate. 

There are other functions in the visdat package that focus on other types of data, for example, `vis_value()`, `vis_binary()`, and `vis_compare()`. To read more about the functions available in `visdat` see the vignette ["Using visdat"](https://CRAN.R-project.org/package=visdat/vignettes/using_visdat.html).

## Explore missingness in variables

Another approach to visualising the missingness in a dataset is to use the `gg_miss_var` plot, as seen in @fig-gg-miss-var.

```{r}
#| label: fig-gg-miss-var
#| fig-height: 1.5
#| fig-width: 3
#| fig-cap: "Number of missing values for each variable. The x axis shows the number of missings, and the y axis shows each variable. We learn total length, and ear length have the most missing values, followed by tail length, hind foot length, weight, and age."
gg_miss_var(rodents)
```

This displays the number of missing values in each variable. We learn similar information to Figure @fig-vis-miss: total length, and ear length have the most missing values, followed by tail length, hind foot length, weight, and age. Just like with `vis_miss()`, we can add in facets in these plots, via the `facet` argument, see @fig-gg-miss-var-facet.

```{r}
#| label: fig-gg-miss-var-facet
#| fig-height: 2.5
#| fig-width: 4
#| fig-cap: "Similar to the above plot but one subplot for each species. We learn that the missingness pattern is pretty similar for each species. We normalise using `show_pct = TRUE` as there are different numbers of observations in each species."

gg_miss_var(rodents, facet = species, show_pct = TRUE)
```

We learn that the species have similar amounts of missing data in their variables.

There are more visualisations available in `naniar` (each starting with `gg_miss_`) - you can see these in the ["Gallery of Missing Data Visualisations" vignette](https://cran.r-project.org/package=naniar/vignettes/naniar-visualisation.html). The plots created with the `gg_miss` family all have a basic theme, but you can customise them by adding components like a standard ggplot object:

```{r}
#| label: gg-miss-var-theme
#| fig-show: hide
gg_miss_var(rodents) + 
  theme_bw() + 
  labs(y = "Number of missing observations")
```

It is also worth noting that for every visualisation of missing data in `naniar`, there is an accompanying function to extract the data used in the plot. This is important as the plot should not return a dataframe - but we want to make the data available for use by the user so it isn't locked into a plot.

You can find these summary plots below, with `miss_var_summary()` providing the dataframe that `gg_miss_var()` is based on.

```{r}
miss_var_summary(rodents)
```

Which also works with `group_by()`:

```{r}
#| results: hide
rodents %>% 
  group_by(species) %>% 
  miss_var_summary()
```

Similarly, there is a `data_vis_miss()` function in the `visdat` package, which returns the data in the format that this visualisation requires.

```{r}
#| results: hide
data_vis_miss(rodents)
```

The aim of these is to provide the data required to make these visualisations, so if people want to create their own more customised versions of `vis_miss()` or `gg_miss_var()` then they can do that.

## Exploring missingness relationships

We can identify key variables that are missing using `vis_miss()` and `gg_miss_var()`, but for further exploration, we need to explore the relationship amongst the variables in this data:

- date
- species
- total_length
- tail_length
- hind_foot_length
- ear_length
- weight
- sex
- age

Let's say that we want to explore the relationship between tail length and ear length.Figure @fig-example-geom-point shows a scatter plot of tail length and ear length.

```{r}
#| label: fig-example-geom-point
#| warning: false
#| echo: true
#| fig-width: 3
#| fig-height: 3
#| fig-cap: "Plot of ear length against tail length. Ear length is on the X axis and tail length is on the Y axis. We learn that there is a reasonable positive correlation of tail length and ear length"

library(ggplot2)
ggplot(rodents, 
       aes(x = ear_length, 
           y = tail_length)) + 
  geom_point()
```

The problem with this is ggplot does not handle missings by default, and removes the missing values. This makes them hard to explore. It also presents the strange question of "how do you visualise something that is not there?". One approach to visualising missing data comes from [`ggobi`](https://en.wikipedia.org/wiki/GGobi) and [`manet`](http://www.rosuda.org/MANET/), where we impute "NA" values with values 10% lower than the minimum value in that variable, which puts these values in a margin area on the graphic.

This imputation is wrapped up in the `geom_miss_point()` ggplot2 geom. @fig-geom-miss-point illustrates this by exploring the relationship between tail length and ear length from the rodents dataset.

```{r}
#| label: fig-geom-miss-point
#| echo: true
#| fig-width: 4
#| fig-height: 3
#| fig-show: hold
#| fig-cap: "Improved plot of tail length against ear length, we can now see the missing values are imputed 10% below the minimum value. The green dots on the Y axis represent tail_length values that have missing ear_length. There aren't any missing values on the X axis, because there aren't times where tail length is missing when ear length is missing. The row of dots in the bottom left corner are missing for both tail length and ear length"

ggplot(rodents, 
       aes(x = ear_length, 
           y = tail_length)) + 
  geom_miss_point() + 
  scale_colour_brewer(palette = "Dark2")

```

Being a proper ggplot geom, it supports all of the standard features of ggplot2, such as **facets** and **themes**. See @fig-ggmissing-facet for an example with faceting by month and a custom theme.

```{r}
#| label: fig-ggmissing-facet
#| echo: true
#| fig-width: 4
#| fig-height: 3
#| fig-cap: "A faceted version of the improved tail length against ear length plot where each month is split out into its own subplot."

ggplot(rodents, 
       aes(x = ear_length, 
           y = tail_length)) + 
  geom_miss_point() + 
  facet_wrap(~species) + 
  theme_dark()

```

## Numerical summaries of missing values

`naniar` provide numerical summaries for missing data. Two convenient counters of complete values and missings are `n_miss()` and `n_complete()`. These work on both dataframes and vectors, similar to `dplyr::n_distinct()`

```{r}
#| label: helpers-n-miss
#| echo: true

dplyr::n_distinct(rodents)
dplyr::n_distinct(rodents$tail_length)

n_miss(rodents)
n_miss(rodents$tail_length)

n_complete(rodents)
n_complete(rodents$tail_length)

```

The syntax for the other numerical summaries in `naniar` are `miss_`, and then `case`, or `var` to refer to cases or variables. There are then `summary`, `table`, `run`, `span`, and `cumsum` options to explore missing data.

`prop_miss_case` and `pct_miss_case` return numeric value describing the proportion or percent of missing values in the dataframe.

```{r}
#| label: prop-miss-case
prop_miss_case(rodents)
pct_miss_case(rodents)
```

`miss_case_summary()` returns a numeric value that describes the number of missings in a given case (aka row), the percent of missings in that row.

```{r}
#| label: miss-case-summary

miss_case_summary(rodents)

```

`miss_case_table()` tabulates the number of missing values in a case / row. Below, this shows the number of missings in a case:

```{r}
#| label: miss-case-table

miss_case_table(rodents)

```

We can interpret this output as follows:

- There are 105 cases with 0 missings, which comprises about 25% of the data.
- There are 48 cases with 1 missing, these make up 6% of the data.
- There are 277 cases with 2 missing, these make up 35% of the data.
- And so on.

Similar to `pct_miss_case()`, `prop_miss_case()`, `pct_miss_var()` and `prop_miss_var()` returns the percent and proportion of variables that contain a missing value.

```{r}
#| label: prop-miss-var
prop_miss_var(rodents)
pct_miss_var(rodents)
```

`miss_var_summary()` then returns the number of missing values in a variable, and the percent missing in that variable.

```{r}
#| label: miss-var-summary

miss_var_summary(rodents)

```

Finally, `miss_var_table()`. This describes the number of missings in a variable:

-   There are 3 variables with 0 missings, comprising 33% of variables in the dataset.
-   There are in the remaining variables similar patterns of missings, but not the exact same number of missing values.

```{r}
#| label: miss-var-table

miss_var_table(rodents)

```

There are also summary functions for exploring missings that occur over a particular span or period of the dataset, or the number of missings in a single run:

-   `miss_var_run()`, and
-   `miss_var_span()`

`miss_var_run()` can be particularly useful in time series data, as it allows you to provide summaries for the number of missings or complete values in a single run. The function `miss_var_run()` provides a data frame of the run length of missings and complete values. To explore this function we will use the built-in dataset, `pedestrian`, which contains hourly counts of pedestrians from four locations around Melbourne, Australia, from 2016.

To use `miss_var_run()`, you specify the variable that you want to explore the runs of missingness for, in this case, `hourly_counts`:

```{r}
#| label: miss-var-run
miss_var_run(pedestrian,
             hourly_counts)
```

The `miss_var_span()` function is used to determine the number of missings over a specified repeating span of rows in variable of a dataframe. Similar to `miss_var_run()`, you specify the variable that you wish to explore, you then also specify the size of the span with the `span_every` argument.

```{r}
#| label: ped-miss-var-span

miss_var_span(pedestrian,
              hourly_counts,
              span_every = 100)

```

# Explore imputed values

Using the [`simputation`](https://cran.r-project.org/package=simputation) package, we impute values for tail_length using the `impute_lm()` function, then visualise the data, as seen in @fig-simpute-invisible.

```{r}
#| label: fig-simpute-invisible
#| message: false
#| echo: true
#| fig-height: 3
#| fig-width: 3
#| fig-cap: "Imputed values are not visible. A plot of tail length by weight. The Imputed tail length values are not visible because we have no way to identify them in the data."

library(simputation)
library(dplyr)

rodents %>%
  impute_lm(tail_length ~ weight + age) %>%
  ggplot(aes(x = weight,
             y = tail_length)) + 
  geom_point()
  
```

Note that we no longer get any warnings regarding missing observations - because they are all imputed! But this comes at a cost: we also no longer have information about where the imputations are - they are now sort of invisible.

We can track a copy of the missing data locations by using the function `nabular()`, which binds another dataset to the current one which notes the locations of the missing data. 
This is a really important idea with `naniar`, but to keep it brief, for each column with missing values, a new column is created to help identify misingness. 
For example, a new column called `ear_length_NA` is created:

```{r}
nabular(rodents) |> 
  select(starts_with("ear_length")) |> 
  head()
```

The key takeaway here is that there is now a copy of the data bound to it, with each column ending in `_NA`, and the values either being "NA" for missing, or "!NA" for not missing. For more details on the theory underlying this, and the benefits of this, we recommend reading our paper, "Expanding Tidy Data Principles to Facilitate Missing Data Exploration, Visualization and Assessment of Imputations" [@Tierney2023].

Using the shadow matrix to keep track of where the missings are, you can actually keep track of the imputations, colouring by what was previously missing in tail_length. For example, let's create the nabular data, then impute the data and plot it in @fig-simpute-visible-lm.

```{r}
#| label: fig-simpute-visible-lm
#| echo: true
#| fig-height: 3
#| fig-width: 4
#| fig-cap: "Regression imputed values of tail length in a scatterplot of tail length vs weight. Weight is on the X axis and tail_length is on the Y axis, and the points are coloured by whether they are imputed - 'NA' indicates a previously missing value that has been imputed. We learn that the regression imputation imputes the values approximately amongst the rest of the data, at the surface level, this appears to be a good imputation."

aq_lm_imputed <- rodents %>%
  nabular() %>% 
  as.data.frame() %>% 
  impute_lm(tail_length ~ weight + age)

ggplot(aq_lm_imputed,
         aes(x = weight,
             y = tail_length,
             colour = tail_length_NA)) + 
  geom_point() + 
  scale_colour_brewer(palette = "Dark2")
  
```

Ah, we learn something important here - there aren't many imputations at all!

Let's contrast this to how poor imputing just the mean value is, using `impute_mean_all()` in @fig-simpute-visible-mean.

```{r}
#| label: fig-simpute-visible-mean
#| echo: true
#| fig-height: 3
#| fig-width: 4
#| fig-cap: "The same plot as above, but using mean imputation. We learn that mean imputation places the imputed values all at a single point, which does not represent the variation we see in the data."

aq_mean_imputed <- rodents %>%
  nabular() %>% 
  as.data.frame() %>% 
  impute_mean_all()

head(aq_mean_imputed)

ggplot(aq_mean_imputed,
       aes(x = Temp,
             y = tail_length,
             colour = tail_length_NA)) + 
  geom_point() + 
  scale_colour_brewer(palette = "Dark2")
```


# Conclusion

In this software corner we have demonstrated the use of the `visdat` and `naniar` R packages for exploring and understanding missing data. 

# References
